Spring 面试题
————————————————————————————————————————————————————————————————————————————————————————————————————————————————
什么是Spring框架？

Spring是一种轻量级框架，旨在提高开发人员的开发效率以及系统的可维护性。
我们一般说的Spring框架就是Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是核心容器、数据访问/集成、Web、AOP（面向切面编程）、工具、消息和测试模块。
6个特征：
核心技术：依赖注入（DI），AOP，事件（Events），资源，i18n，验证，数据绑定，类型转换，SpEL。
测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。
数据访问：事务，DAO支持，JDBC，ORM，编组XML。
Web支持：Spring MVC和Spring WebFlux Web框架。
集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。
语言：Kotlin，Groovy，动态语言。

————————————————————————————————————————————————————————————————————————————————————————————————————————————————

列举一些重要的Spring模块：

Spring Core：基础，可以说Spring其他所有的功能都依赖于该类库。主要提供IOC和DI功能。
Spring Aspects：该模块为与AspectJ的集成提供支持。
Spring AOP：提供面向方面的编程实现。
Spring JDBC：Java数据库连接。
Spring JMS：Java消息服务。
Spring ORM：用于支持Hibernate等ORM工具。
Spring Web：为创建Web应用程序提供支持。
Spring Test：提供了对JUnit和TestNG测试的支持
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Spring IOC和AOP的理解：

IOC
IOC是基于反射机制来实现的。
IOC（Inversion Of Controll，控制反转）是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由给Spring框架来管理。
将对象之间的相互依赖关系交给IOC容器来管理，并由IOC容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。

AOP
AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。
Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Spring中的bean的作用域有哪些？

1.singleton：唯一bean实例，Spring中的bean默认都是单例的。
2.prototype：每次请求都会创建一个新的bean实例。
3.request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
4.session：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。
5.global-session：全局session作用域，仅仅在基于Portlet的Web应用中才有意义，Spring5中已经没有了。Portlet是能够生成语义代码（例如HTML）片段的小型Java Web插件。它们基于Portlet容器，可以像Servlet一样处理HTTP请求。但是与Servlet不同，每个Portlet都有不同的会话。


————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Spring框架中用到了哪些设计模式

1.工厂设计模式：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。
2.代理设计模式：Spring AOP功能的实现。
3.单例设计模式：Spring中的bean默认都是单例的。
4.模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到了模板模式。
5.包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
6.观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。
7.适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller。

————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@Component和@Bean的区别是什么

1.作用对象不同。@Component注解作用于类，而@Bean注解作用于方法。
2.@Component注解通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用@ComponentScan注解定义要扫描的路径）。
  @Bean注解通常是在标有该注解的方法中定义产生这个bean，告诉Spring这是某个类的实例，当我需要用它的时候还给我。
3.@Bean注解比@Component注解的自定义性更强，而且很多地方只能通过@Bean注解来注册bean。比如当引用第三方库的类需要装配到Spring容器的时候，就只能通过@Bean注解来实现。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

将一个类声明为Spring的bean的注解有哪些？

我们一般使用@Autowired注解去自动装配bean。而想要把一个类标识为可以用@Autowired注解自动装配的bean，可以采用以下的注解实现：
1.@Component注解。通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪一个层，可以使用@Component注解标注。
2.@Repository注解。对应持久层，即Dao层，主要用于数据库相关操作。
3.@Service注解。对应服务层，即Service层，主要涉及一些复杂的逻辑，需要用到Dao层（注入）。
4.@Controller注解。对应Spring MVC的控制层，即Controller层，主要用于接受用户请求并调用Service层的方法返回数据给前端页面。

————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Spring 事务概述：

事务是一个不可分割操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Spring事务管理的方式有几种？

1.编程式事务：在代码中硬编码（不推荐使用）。
2.声明式事务：在配置文件中配置（推荐使用），分为基于XML的声明式事务和基于注解的声明式事务。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

什么是事务管理？

所谓事务管理，实质上就是按照给定的事务规则来执行提交或者回滚操作
其中，“给定的事务规则”是用 TransactionDefinition 表示的，“按照……来执行提交或者回滚操作”是用 PlatformTransactionManager 表示的
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

事务隔离级别：

所谓事务的隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：
TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，该级别就是 TransactionDefinition.ISOLATION_READ_COMMITTED；
TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据，该级别不能防止脏读和不可重复读，因此很少使用该隔离级别；
TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。
TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。
TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是，这将严重影响程序的性能，通常情况下也不会用到该级别。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

事务的传播行为：

所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。
TransactionDefinition接口定义了如下几个表示传播行为的常量：
TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 
TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 　
TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 　
TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

事务超时：

所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。
在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。
————————————————————————————————————————————————————————————————————————————————————————————————————————————————

事务的只读属性：

事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。
所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。
如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。
在 TransactionDefinition接口中，以 boolean 类型来表示该事务是否只读
————————————————————————————————————————————————————————————————————————————————————————————————————————————————
事务的回滚规则：
通常情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。
如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务。这通常也是大多数开发者希望的处理方式，也是 EJB 中的默认处理方式。
但是，我们可以根据需要人为控制事务在抛出某些未检查异常时任然提交事务，或者在抛出某些已检查异常时回滚事务。

————————————————————————————————————————————————————————————————————————————————————————————————————————————————
编程式事务管理：
所谓编程式事务管理，就是需要人工在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法。


声明式事务管理：
所谓声明式事务管理是建立在 Spring AOP 机制之上的，其本质是对目标方法前后进行拦截，并在目标方法开始之前创建或者加入一个事务，
在执行完目标方法之后根据执行情况提交或者回滚事务。















